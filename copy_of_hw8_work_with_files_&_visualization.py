# -*- coding: utf-8 -*-
"""Copy of HW8 -  Work with Files & Visualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LdUXHg4Hz06jLNq09f5hUapBonMdkibc

# Homework Assignment #8 (**50 points**)

This assignment will contain three parts, you are free to pick any questions you want to complete. (The additional points you earn will be treated as bonus points.): 
- Part I (**25 pts**): Review the syntax that I introduced in the class as well as Lab scripts, you can write in a function style or a program
- Part II (**25 pts**): Applying basic data cleaning and data visualization
- Part III (**25 pts**): Challenging problem, you can treat it as bonus problem, mainly for very advanced students. This week we will work on **Image Processing**.

## Part I (**25 pts**)

### Q1. **Addition (4 pts )**

One common problem when prompting for numerical input occurs when people provide text instead of numbers. When you try to convert the input to an int, you'll get a ``ValueError``. Write a program that prompts for two numbers. Add them together and print the result. Catch the ValueError if either input value is not a number, and print a friendly error message. Test your program by entering two numbers and then by entering some text instead of a number. 

To be specific, in the question, you are asked to complete the following tasks:
- Write a program that prompts for two numbers (**1 pt**).
- Add them together and print the result (**1 pt**).
- Catch the ``ValueError`` if either input value is not a number, and print a friendly error message(**1 pt**).
- Test your programs by entering two numbers and then by entering some text instead of a number(**1 pt**).
"""

try:
  number1 = input("Enter first number: ")
  number1 = int(number1)

  number2 = input("Enter second number: ")
  number2 = int(number2)

except ValueError:
    print("Not an integer")

else:
  sum = number1 + number2
  print("Sum: " + str(sum))

"""### Q2. **Adition Calculator (4 pts)**

Wrap your code from Q1 in a while loop so the user can continue entering numbers even if they make a mistake and enter text instead of a number.

To be specific, in the question, you are asked to complete the following tasks:
- Write a while loop to wrap your code from Q1 (**2 pts**)
- Continue entering number even if they make a mistake (**2 pts**)
"""

print("Enter 'quit' to quit program")

while True:
    try:
        number1 = input("\nGive me a number: ")
        if number1 == 'quit':
            break

        number1 = int(number1)

        number2 = input("Give me another number: ")
        if number2 == 'quit':
            break

        number2 = int(number2)

    except ValueError:
        print("Sorry, I really needed a number.")

    else:
        sum = number1 + number2
        print("The sum of " + str(number1) + " and " + str(number2) + " is " + str(sum))

"""### Q3. **Cats and Dogs (4 pts)**

Make two lists ``cats`` and ``dogs``. Store at least three names of cats in the first list and three names of dogs in the second list. Write a program that tries to read these lists and print the contents of the list to the screen. Wrap your code in ``try-except`` block to match the ``NameError`` error, and print a friendly message if a list is missing.

To be specific, in the question, you are asked to complete the following tasks:
- Make two lists: ``cats`` & ``dogs``. Both lists contain at least three names of cats and dogs. (**2 pts**)
- Write a program that tries to read these lists and print the contents of the list to the screen. (**1 pt**)
- Wrap your code in ``try-except`` block to match the ``NameError`` error, and print a friendly message if a list is missing. (**1 pt**)
"""

cats = ["Max", "Stan", "Heath"]
dogs = ["Fluffy", "Geronimo", "Sam"]

try:
  for x in cats:
    print(x)
  for y in dogs:
    print(y)
except NameError:
  print('The list does not exist.')

cats = ["Max", "Stan", "Heath"]


try:
  for x in cats:
    print(x)
  for y in dogs:
    print(y)
except NameError:
  print('The list does not exist.')

"""### Q4. **Common Words (4 pts)**

Download the [Pride_and_Prejudice_Chapter1.txt](https://drive.google.com/file/d/1hqYG6m6sA28yEHuG7LHWHwAusvnF7s4R/view?usp=sharing).

You can use ``count()`` method to find out how many times a word or phrase appears in a string. For example, the following code counts the number of times 'rows' appears in a string:
```python
In [1]: line = "Row, row, row your boat"

In [2]: line.count('row')
Out[2]: 2

In [3]:line.lower().count('row')
Out[3]: 3
```
Notice that converting the string to lowercase using ``lower()`` catches all appearnaces of the word you're looking for, regardless of how it's formatted.

Write a program that reads the files you found at this text file and determines how many times the word ``"the"``, ``"you"``, and ``"I"`` appear. 

To be specific, in the question, you are asked to complete the following tasks:
- Write a program that reads the files ``Pride_and_Prejudice_Chapter1.txt`` (**1 pt**).
- Determine how many times the word ``"the"``, ``"you"``, and ``"I"`` appear in this text. Make sure you want to make it as case insensitive(**3 pts**).
"""

with open("/content/Pride_and_Prejudice_Chapter 1.txt") as file_object:

  contents = file_object.read()
  occurrences1 = contents.lower().count("the")
  occurrences2 = contents.lower().count("you")
  occurrences3 = contents.count("I")
print("Number of occurrences of word you: ", occurrences1)
print("Number of occurrences of word the: ", occurrences2)
print("Number of occurrences of word I: ", occurrences3)

"""### Q5. **Guest Book(5 pts)**

Write a ``while`` loop that prompts the users for their name. When they enter their name, print a greeting to the screen and add a line recording their visit in a file called ``guest_book.txt``. Make sure each entry appears on a new line in the file.

To be specific, in the question, you are asked to complete the following tasks:
- Write a ``while`` loop that prompts the users for their name (**2 pts**)
- When entering their name, print a greeting to the screen (**1 pt**)
- Add a line recording their visit in a file called ``guest_book.txt`` (**1 pt**)
- Make sure each entry appears on a new line in the file.(**1 pt**)
"""

filename = 'guest_book.txt'

print("Enter 'quit' when you are finished.")
while True:
    name = input("Enter your name? ")
    if name == 'quit':
        break
    else:
        with open(filename, 'a') as f:
          f.write(name + "\n")
        print("Hi " + name + ", you've been added to the guest book.")
    this_file = open("guest_book.txt")
    filecontents = this_file.read()
print("Guest Book Contents: ")
print(filecontents)

"""### Q6. **Programming Poll (4 pts)**

Write a ``while`` loop that asks people why they like programming. Each time someone enters a reason, add their reason to a file that stores all the responses. Make sure each entry appears on a new line in the file.

To be specific, in the question, you are asked to complete the following tasks:
- Write a ``while`` loop that asks people why they like programming (**2 pts**)
- When enters a reason, add their reason to a file (**1 pt**)
- Make sure each entry appears on a new line in the file. (**1 pt**)
"""

filename = 'programming.txt'

print("Enter 'quit' when you are finished.")
while True:
    answer = input("Why do you like programming? ")
    if answer == 'quit':
        break
    else:
        with open(filename, 'a') as f:
          f.write(answer + "\n")
        print("Why you like programming: " + answer)
    this_file = open("programming.txt")
    filecontents = this_file.read()
print("Reasons People Love Programming: ")
print(filecontents)

"""## Part II (**25 pts**): **Data analysis and visualization**

Python with Pandas is a tremendously powerful tool for data analysis and visualization. In this part, we will use Pandas to analyze the Google Play Sotre data set, [googleplaystore_user_reviews.csv](https://drive.google.com/file/d/1ruHsSLwq0Nwu-aHaNbnCV1e7v7ODv8Be/view?usp=sharing) & [googleplaystore.csv](https://drive.google.com/file/d/1wT3-mUxIVCPPqOI_DtAPMPpWx9AV7ZdB/view?usp=sharing). I will ask you to manipulate the data in certain ways in order to show different interesting visualizations. 

Specifically, you are asked to complete the following **SEVEN** tasks.

- Task #1 - Task #3: basic data cleaning
- Task #4 - Task #7: basic visualization
- Task #8 - Task #9: more advanced data manipulation (Bonus points for this assignments)

### **Task #1 (2 pts)**

1. Load the ``googleplaystore_user_reviews.csv``(review) and ``googleplaystore.csv``(apps) data set as pandas DataFrames. You should use the ``pd.read_csv()`` fnction for this purpose.
"""

import pandas as pd
df1 = pd.read_csv("/content/googleplaystore_user_reviews.csv")
df2 = pd.read_csv("/content/googleplaystore.csv")

"""### **Task #2 (2 pts)**

2. Delete any review that does not contain either a ``Translated_Review`` or a ``Sentiment``. The ``pd.dropna`` function will be helpful for this. 
"""

df_1 = df1.dropna(subset = ['Translated_Review', 'Sentiment'])

"""### **Task #3 (1 pts)**

3. Remove any apps whose ``Rating`` is invalid (>5)
"""

df2 = df2[df2['Rating']<=5]
len(df2)

"""### **Task #4 (5 pts)**

4. Produce a **pie chart** with the ``Android Ver`` requirements for the different apps. Group together all versions that make up less than **5%** of the total apps into a single ‘Others’ category. You will find the ``df.value counts()`` function useful for solving this problem.

This should look similar to the following graph:

![picture](https://drive.google.com/uc?export=view&id=1AEqPLSxPhY0CHrUB_OL62bIFetSKB6q0)

"""

import numpy as np
series = df2.value_counts(df2['Android Ver'])
mask = (series/series.sum() * 100).lt(5)
df2['Android Ver_Pie'] = np.where(df2['Android Ver'].isin(series[mask].index), 'other', df2['Android Ver'])

df2['Android Ver_Pie'].value_counts().plot(kind = 'pie',
                                    autopct= '%1.1f%%',
                                    title = 'Android Ver')

"""### **Task #5 (5 pts)**

5. Create a similar **pie chart** for App's ``Category``. In this case, group together categories that make up less than **3%** of the apps. 

This should look similar to the following graph:

![picture](https://drive.google.com/uc?export=view&id=1phDt3-Hcptybp886I8BIyL0edSPuzDDa)
"""

import numpy as np
series = df2.value_counts(df2['Category'])
mask = (series/series.sum() * 100).lt(3)
df2['Category_Pie'] = np.where(df2['Category'].isin(series[mask].index), 'other', df2['Category'])

df2['Category_Pie'].value_counts().plot(kind = 'pie',
                                    title = 'Category')

"""### **Task #6 (5 pts)**

5. Show **histograms** of the ``Rating`` across all apps, with **20 bins**. 


This should look similar to the following graph:

![picture](https://drive.google.com/uc?export=view&id=1iAHsM1ulaaS2x7eNebWO_L8WhE2MCsLm)
"""

df2['Rating'].hist(bins= 20)

"""### **Task #7 (5 pts)**

7. Plot a **bar chart** with the different ``Sentiment``.

This should look similar to the following graph:

![picture](https://drive.google.com/uc?export=view&id=1ykrORzITP1Sp2yUMocAj4wn91Lc-CNrc)
"""

df1['Sentiment'].value_counts().plot(kind = 'bar', title = 'Sentiment', label = 'Counts')

"""### **Extra Task #8 (5 pts)**
8.  Combine the two DataFrames into a single one, based on the ``App names``. You should make sure that all apps from the apps DataFrame are kept, and no app beyond those is added. The ``pd.merge`` function
will be useful for this
"""



"""### **Extra Task #9 (10 pts)**
9. Group the ``Sentiment`` by rounded Rating, and produce a **bar chart** where you display the different sentiments grouped by rating. You might find the ``pd.groupby``, ``np.round``, and ``df.unstack`` functions helpful for this task. 
"""



"""## Part III (**25 pts**): **Image Processing**

In this part, you will have the opportunity to write programs that algorithmically alter images. 

**How are the images represented?**

The key data structure in the code is *rgbdata*, which contains all of the image's pixel data.

***But how does it contain that data?*** This is the key to changing it successfully!

*rgbdata* is a list of pixel rows.

- Each *pixel* row is, in turn, a list of pixels
-- Each *pixel* is, in turn, a list of three integers: the pixel's red intensity, its green intensity, and its blue intensity (each 0 to 255).
For example, here is a complete 2x3 image (with two rows of three pixels in each row):

```python

Im_pix = [[[  0,   0, 255],  [  0,   0, 255],  [0,   0,   0]],  # first row of three pixels
          [[255, 255, 255],  [255,   0,   0],  [0,   0, 255]]]  # second row of three pixels 
```
Here, in the first row, the top-left and top-middle pixels are pure blue, and the top-right pixel is black.

The bottom-left pixel is white, the bottom-middle pixel is red, and the bottom-right pixel is blue.

With Rhode-Island-sized pixels, this image looks like this:

![picture](https://drive.google.com/uc?export=view&id=1nFp_D6FKoxdh_9BqvERNxggAdC5izfCj)

The list comprehension in the example code has two levels:

- The outer level iterates through each row of the image (each one is named row, the runner variable for that portion)
-- The code at this outer level is for row in rgbdata
- The inner level iterates through each pixel of the image (each one is named p, the runner variable for this portion)
-- The code at this inner level is for p in row
- Remember that p itself is a list of three integers: ``[red, green, blue]`` or ``[r,g,b]``

With this model in mind, you're ready to "rearrange" the data however you'd like! That's next...

**Functions for you to write**

First, we will focus on pixel-level operations. For making **grayscale and binary** images, you will compute the brightness or luminance of each pixel. In essence, it's how bright or dark the colors in a pixel are (compared to white).

As Wikipedia calculates it, luminance is 21% red, 72% green, and 7% blue. Intuitively, this makes sense because if you think of standard red, green, and blue, green is the lightest and thus has highest positive impact on luminance, while blue is darker and has a lower value for luminance. This is useful! You're going to calculate luminance for pixel operations.

**Palying with Pixels**

![picture](https://drive.google.com/uc?export=view&id=1KDdKZeqe_xLqy17Kb-eBuoFGBCvmmbZY)
![picture](https://drive.google.com/uc?export=view&id=1qkZdneIHEKBNEayRe5tnbjk_uJg3XGYi)

We have provided an *invert* example called ``invert``, which modifies an image to create its negative. That is, all color values are 255 minus their original value. Especially note the use of list comprehension, which iterates over every pixel in the image and calls a function to create new RGB values. It's easiest to also write ``grayscale`` and ``binarize`` in the same format: a main function that accepts user input and contains a list comprehension that calls a helper function on each pixel. We leave the details flexible, but here is a possible signature for binarize (see below for more details on what binarize does):
- ``def binarize(rgbdata, threshold)``  It's ok to include more arguments! **(10 pts)**

Then, write a function called ``grayscale`` that modifies an image to make it grayscale. For this, you'll want to do something similar to invert, except that the new pixel-changing function will calculate the luminance of the pixel using the ratios described above. Since luminance is an indication of how white or black a pixel is, having your helper function return a list of RGB values in grayscale is easy—just return the same value in each of the three color channels! A possible signature:
- ``def grayscale(rgbdata)``  You can use another argument here, but you may not need one. (**15 pts**)
"""

#
# the Pillow (PIL) library supports image reading and writing
#     these functions make sure that the pixels are 
#     in "canonical" image form:
#     each image's rgbdata is
#         a list... of lists (rows)
#     each row is
#         a list... of lists (pixels)
#     each pixel is
#         a list of three integers:  [r,g,b], each from 0-255 (inclusive)
#

# see examples in the cells below

from PIL import Image
import time

def saveRGB( PX, filename="out.png" ):
    """ saves a list-of-lists-of-lists of rgb pixels where
        len(PX) == the # of rows
        len(PX[0]) == the # of columns
        len(PX[0][0]) should be 3 (rgb)
    """
    boxed_pixels = PX
    print( 'Starting to save', filename, '...' )
    W, H = getWH( boxed_pixels )
    im = Image.new("RGB", (W, H), "black")
    px = im.load()
    for r in range(H):
        #print( ".", end="" )
        for c in range(W):
            bp = boxed_pixels[r][c]
            t = tuple(bp)
            px[c,r] = t
    im.save( filename )
    time.sleep(0.42)   # give the filesystem some time...
    print( filename, "saved." )

def getRGB( filename="spam.png" ):
    """ reads a png or jpg file 
        returns the pixels as a list-of-lists-of-lists
        this is accessible, but not fast: Use small images!
    """
    original = Image.open(filename)
    print(f"Reading image from {filename} :")
    print(f"  Format: {original.format}\n  Size: {original.size}\n  Mode: {original.mode}")
    WIDTH, HEIGHT = original.size
    px = original.load()
    PIXEL_LIST = []
    for r in range(HEIGHT):
        row = []
        for c in range(WIDTH):
            row.append( px[c,r][:3] )
        PIXEL_LIST.append( row )
    return PIXEL_LIST

def getWH( PX ):
    """ returns the width and height (in pixels) 
        height = # of rows (# of top-level elements)
        width = # of columns (# of elements inside each top-level element)
    """
    H = len(PX)
    W = len(PX[0])
    return W, H

def binaryIm( s, cols=8, rows=8 ):
    """ returns rgb values for an image with
        rows (number of rows)
        cols (number of cols)
        from the string s (of only 0's and 1's)
    """
    PX = []
    for row in range(rows):
        ROW = []
        for col in range(cols):
            c = int(s[row*cols + col])*255
            px = [ c, c, c ]
            ROW.append( px )
        PX.append( ROW )
    #saveRGB( PX, 'binary.png' )
    return PX

#
# example of how to use the binaryIm function
#
s = '1010101001010101'*4   # checkerboard!
PX = binaryIm(s,8,8)       # converted to pixels
print(PX)                  # printed as numbers
show_image(PX)             # shown as an image...

#
# matplotlib is a commonly used Python graphing library
#

# allows us to use plt as the library name
import matplotlib.pyplot as plt  

#
# helper function to allow setting the image size
#
def set_size(width, height, ax=None):
    """ w, h: width, height in inches """
    w = width; h = height
    if not ax: ax=plt.gca()  # gets current axes
    l = ax.figure.subplotpars.left
    r = ax.figure.subplotpars.right
    t = ax.figure.subplotpars.top
    b = ax.figure.subplotpars.bottom
    figw = float(w)/(r-l)
    figh = float(h)/(t-b)
    ax.figure.set_size_inches(figw, figh)
    
#
# wrapper for matplotlib's imshow function
#
def show_image( rgbdata, hgt_in=5.42, wid_in=5.42 ):
    """ shows an image whose pixels are in rgbdata 
        note:  rgbdata is a list-of-rows-of-pixels-of-rgb values, _not_ a filename!
        hgt_in is the desired height (in inches)
        wid_in is the desired width (in inches)
        _but_ the library will not change the aspect ratio (takes the smaller)
        by default, the hgt_in and wid_in are 5.42 in.
    """
    fig, ax = plt.subplots()           # obtains the figure and axes objects
    im = ax.imshow(rgbdata)            # this is matplotlib's call to show an image 
    set_size(width=wid_in, height=hgt_in)  # matplotlib will maintain the image's aspect ratio
    # ax.axis('off')   # turns off the axes (in units of pixels)
    plt.show()

# images provided:  flag.png hopper.jpg olin.png spam.jpg in.png out.png
rgbdata = getRGB( "olin.png" )

#
# building intuition of the image as a list-of-lists-of-lists:
# 

# each top-level element is one row:
print(rgbdata[42])

#
# each row's elements are individual pixels:
#
print(rgbdata[42][42])

# we can change them!
rgbdata[42][42] = [255,0,0]  # 255 is red, 0 is green, 0 is blue

#
# display the image with show_image
#
show_image( rgbdata )  # default size

# show_image( rgbdata, 10, 10 )  # much larger

#
# First pixel-processing example:   "Invert" the image (255 - each color)
#

def new_pixel( rgbpixel ):
    """ rgbpixel should be in the form [r,g,b]
        returns [newred, newgreen, new blue],
        based on their old versions!
    """
    [r,g,b] = rgbpixel
    newr = 255-r
    newg = 255-g
    newb = 255-b
    return [newr, newg, newb]

def transform_image( rgbdata ):
    """ transforms an image, returning a new image 
        applies the function new_pixel to each pixel
    """
    new_rgbdata = [[ new_pixel(pix) for pix in row] for row in rgbdata]
    return new_rgbdata

new_rgbdata = transform_image(rgbdata)

show_image(new_rgbdata)